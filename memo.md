## Ch05 ビット操作

- Nビット整数としての-Kの2審表記は，(2^(N-1)-K)の先頭に1をつけたもの．
- >>>: 論理右シフト，>>: 算術右シフト

## Ch06 数学と論理パズル

- エラトステネスの篩
- ルールを書き出すことで解きやすくしていく．
- 最大の移動回数．
    - 1つだけ重いボールの問題．
        - 最悪ケースのバランスをとる．
- 6.1 錠剤はそれぞれの瓶に複数入っている．
- 6.2 不等式を解けば済む．
- 6.3 偶奇を色などで分けると説明できる．
- 6.4 全部同じ方向（左右とすると分かる）を選ぶときだけ衝突しない．
- 6.5 2つの数が互いに素なとき，1から2数の和まですべて求められる．
- 6.6 初期状態からの積み上げ．1のときと同じパターンが2，3,..でも同様に成り立つことを示す．
- 6.7 全体について考えるため，家族でのグループ化は不要．
    - シミュレーションは1件ずつランダムに実行していけばよい．
- 6.8 多くの最大化/最小化問題と同じく，最悪ケースのバランスをとる．
    - → 完璧なシステムを想定する．
        - 卵1がどこで割れたかによらず，(卵1を落とした回数) + (卵2を落とした回数)が一定値になる．
        - 卵1の最悪ケースと卵2の最悪ケースがバランスするように考える．
- 6.9 約数の個数は，2乗の数のときのみ奇数になる．
    - 約数のペアについて，2乗する数のみ1つしか数がないため．
- 6.10 better: 桁数ごとにグループ化．
    - best: 数字を2進数表現する．
    - 検査数分の組み合わせで検査対象を一意に表現できるか考える．

## Ch07 オブジェクト指向設計

- 誰が，どのように使うものなのかを確認する．
- 中心になるオブジェクトを定義する．
- 関係性を分析する．
- 行動を調査する．
- 7.1 どんな振る舞いが必要かを考える・確認する．
- 7.2 ファイルのコメントに色々記載．
- 7.3,7.4 特に新しいことがなさそうなのでパス．
- 7.5 ディスプレイとかユーザマネジャーとかの支援ドメインを分ける．
    - OnlineReaderSystemクラスでコーディネートする．
- 7.6 方向と形をenumで実装する．それぞれにget_opposite, fits_withをimpl.
    - ジグソーパズルの形は凹凸平坦の3つのみらしい．
- 7.7 コンピュータネットワーク第5版とかデータ指向アプリケーションデザインとかの話題．
    - 詳細なコードは不要なので，振る舞いの一覧を抽出する．
    - 要考慮ポイント
        - ユーザのオンラインの確認．
        - 非同期の情報の対処．
        - スケーラビリティ．
        - DoS攻撃．
    - グループチャットとプライベートチャットがコンバセーショントレイトを実装する．
- 7.8 シングルトンについて考える問題らしい．
    - 黒と白のenumでよさそう．
    - 基本はゲームクラスだけで簡潔できそう．
    - Boardを作るなら構造体とする．
- 7.9 queueにイテレータを実装した．
    - リングバッファを使えばよいため．
- 7.10 
    - ある範囲へのランダムな設定
    - → 設定する分を先にすべて設定し，範囲内でランダムに入れ替える．
    - 複数の値に影響するものは，影響を受ける方ではなく影響を与える方で走査するとよい場合がある．
- 7.11 ファイルとディレクトリだけで構成されるもの．
    - Entryで抽象化する．
    - 複雑でない問題．
- 7.12 get_node_for_key()とhash_code_of_key()を実装する．ほかはそれらを使えば満たしていける．

## Ch08 再帰とDP

- 再帰
    - basecaseに対する処理が重要．
    - 引数がbasecaseに近づくようにする．

- 8.2 DPとかグラフとか使えばいける．
    - 立ち入り禁止の情報を持ったテーブルを作る．
- 8.4
    - 再帰の場合は，初期状態からの積み上げを行う．P(2) + a3 とP(2)を統合する．
    - 1から2^nまでのすべての整数で，各要素のありなしを判断する．
- 8.5 
    - 掛け算: 全体の半分を数えてそれを2倍する．奇数の場合は，1つ分は別で足せばよい．
- 8.6 ハノイの塔
    - move_disks(n, origin, dest, buffer)を実装すればできる．
    - 初期状態からの積み上げ，n-1とnの関係がある．→ 再帰で解く．
    - 効率化はない．
- 8.7 順列
    - すべてのn-1文字の順列にn文字目を足すことで構築する．
- 8.8 重複排除のためのハッシュテーブル．
    - ハッシュテーブルを使用して再帰する．
- 8.9 括弧の組み合わせの生成．
    - 2通りでそれぞれ再帰呼び出しする．あり得ない（閉じが開きより多い）場合は除外するため結果リストに追加せずリターン．
    - 残りが開きも閉じも0になったら結果リストに加える．
- 8.10 塗りつぶし
    - 上下左右への再帰でOK．
    - 再帰呼び出しの前に呼び出し元の色を変えてしまうことで，無限を回避する．
    - dfs, bfsで実装できる．
- 8.11 
    - 金額ではなく，金種ごとにループすることで，重複を回避できる．
        - 組み合わせになってほしくないときは，重複を回避するようなループを組む．
- 8.13
    - 高さでソートして，それぞれが1番下の場合でループし，再帰呼び出し．
    - または，ある箱を選ぶかどうかそれぞれの場合で再帰呼び出しをして，maxを取る．
        - 特定の底に対する最大の高さをメモ化する．
- 8.14 basecase: 1つの文字になるとき．
    - 式を分割・文字を減らしていく．
    - 式の塊をメモのキーにする．

## Ch09 スケーラビリティとシステムデザイン

- 質問の対処．
- 9.1
    - 4つの観点
        - clientに優しい
        - 自分たちにも優しい
        - 将来の要求に対しても柔軟に対応できる
        - スケーラビリティと効率
    - 案1: FTPサーバのようなものを使って，テキストファイルを取得
    - 案2: SQL DB
    - 案3: XML
- 9.2
    - いくらかのユーザではグラフでBFS
    - 数百万のユーザでは，マシンが分散する
- 9.3
    - 無限ループ: グラフの問題として対応．
    - ウェブページの定義が必要
- 9.4
    - ハッシュでグループ化する
    - ファイルではなくマシンで分けると，並列処理ができるが，マシンの作動の失敗の対応が必要で複雑
- 9.5
    - 単一マシンのシステムのキャッシュを設計: 連結リストと，連結リスト内のノードを求めるためのhash table
    - 複数マシンに分けるために，ハッシュを使う
    - コンテンツの更新: 自動タイムアウトを設定するのが〇
    - 機能強化
        - 頻度の高いクエリ，クエリのマシンへの割り当て，自動タイムアウト
- 9.6
    - 問題の範囲を決める→合理的な前提→主要な構成→主要な問題点の特定
    - DB処理のコストを考えて，MapReduceなどを使う．
- 9.7
    - 9.6と同じフロー
    - 問題点
        - 非同期にしてレスポンス改善
        - 作業の優先度，予算超過の確認作業→取引の発生ごとに確認作業をキューに入れる，ユーザの優先度，膨大な量のデータを取得・分析→ログベースの処理
- 9.8
    - アクセスの偏り → キャッシュ
    - ファイルを含むDBを素早く見つける → DBのシャーディング
    - URL生成 → GUIDは読みづらい．文字と数字の10文字の並びで36^10の文字列を生成できる．
        - 衝突の検出と再試行で十分．
    - 分析のためのデータの量の問題 → 確率を使って保存する量を減らす．



## Ch10 ソートと探索

- 10.3
    - 二分探索っぽくやる．左端と中央の大小を見て，ソート済みがどちら側かを判定，ソート済みの中に対象があるか見る．
- 10.4
    - 範囲が不明なときは，指数関数的に探索していくと，O(logN)でサイズを求められる．
    - あとは二分探索．
- 10.5
    - 二分探索．中間が空だったらそこから近い空でない位置を探す．
- 10.6
    - 非常に大きいサイズのデータのソート．
    - → メモリに展開しない．→ 分割して個別にソートしファイルに保存． → それぞれをマージして完了する．
- 10.7
    - 1GB: Bはバイト，80億ビット使えるということ．
    - 1から最大値までの有無を書くビットで表す．実装はバイト配列を使っている．
    - 10MBの場合は，分割の範囲を計算する．
- 10.8
    - 4KB = 4 * 8 * 2^10 > 32000なので，32000ビットのビットベクトルを用意して，各ビットに整数値を対応させればOK．
- 10.9
    - 最初は各行での二分探索を考える．対象より大きい値の列は除外できることに気づける．
    - あるいは，四角に取ると，左上と右下がそれぞれ最小・最大となることが分かる．対角線上もソートされているため，分割地点を二分探索する．
- 10.10
    - 順番を取れるようにしておくなら，二分探索木を作るとよい．
    - 平衡二分探索木ならO(logN)
- 10.11
    - 順序は相対的なもの．特定の数字で考えて問題ない．
    - 3つの要素ごとに関係がある → 3つの要素でmaxを山にしていけばよい．


## Ch11 test

- 要点
    - 全体像の理解
    - 部品の統合
    - 系統立て
    - 実用性
- 現実のもののテスト
    - 誰が何のために使うか．
    - 使用事例
    - 使用限度
    - 負荷・不具合の条件
    - テスト方法．
- ソフトウェアの一部のテスト: 詳細に重点がある．
    - ブラックボックス vs ホワイトボックス
        - ソフトウェアに対するアクセスの度合の違い．
        - ブラックボックスでは，ソフトウェアそのもののみでテスト．
    - approach
        - ブラックボックス or ホワイトボックス
        - 誰が何のために使うか．
        - 使用事例
        - 使用限度
        - 負荷/不具合の発生条件
        - テスト方法
            - 手動 or 自動
            - 手動でしかテストできないものがある．
- 関数のテスト
    - 簡単な部類．
    - テストケースの定義
        - 通常，極端，Nullと不正な入力，変わった入力
    - 予期される結果の定義
    - テストコードを書く．
- 問題解決
    - 問題の詳細を理解する．
        - 期間，バージョン，OS，頻度，タイミング，エラーメッセージの有無
    - 問題の切り分け
        - フローの中のどこが問題なのか．
    - 特定の管理可能なテストを作る．

- 11.1
    - unsigned: 符号なし．
        - 無限ループ
        - %d → %u
- 11.2
    - ランダムクラッシュの一般的な原因
        - ランダムな変数
        - 未初期化の変数
        - メモリリーク
        - 外部要因
    - 特定の要素や流れでのみ発生する場合もある
    - 1つずつ要素を消していく
        - ほかのアプリケーションを閉じる
        - リソースの使用を追う
        - 無効にできるものを無効化
        - ほかのマシン上で動かす
    - 検査用ツールを使う．
        - e.g. 未初期化変数を検出する実行時用のツール
    - ブレインストーミングの能力も求められる
        - 系統立てて考える．
- 11.3
    - 極端な場合の検証
        - 負，範囲外，内部の状態など
    - 一般的なテスト
        - 各種類について考える必要がある．
        - すべての可能性の検証はできないので，重要な部分に焦点をあてる．
- 11.4
    - 負荷テスト
        - 最大稼働能力，パフォーマンスを妨げる可能性のあるボトルネックを特定，負荷の変動へのアプリケーションの反応の確認．
    - 測定基準
        - 応答時間，処理能力，リソースの使用率，システムが耐えうる最大負荷
    - ツールがなければ自作
        - 数千の仮想ユーザを用意して，同時にアクセスする状況をシミュレート
        - 各スレッドが実際のユーザのようにウェブページを読み込むようにした，数千のスレッドを持つマルチスレッドのプログラムをかく．
            - 各ユーザごとに応答時間やデータの入出力などの測定を行えるようにする．
        - 集めたデータに基づいて分析，許容される値と比較する．
- 11.5
    - 5W1Hが分かるように質問する．
    - → テストの対象を正確に理解する．
    - ものの第一印象と実際のものが異なるようになっている．
    - 構造が重要．
    - 事実の確認．
        - フェルトペンかどうか，インクが使える色かどうか確認．
    - 意図した用途
        - 絵を描く場合，衣類にちゃんと描けるか．
    - 使用目的
        - 衣類を洗った場合，時間がたっても洗い落とすことができるか．熱湯・ぬるま湯・霊枢で洗い落とせるか．
    - 安全性
        - 子供にとって有害でないか．
    - 意図しない用途
        - 子供がペンを踏んだり投げたりしたときに耐えられるか確認．
- 11.6 
    - 安全性と信頼性が優先． ← システムの優先順位を確認する．
        - 口座は常に保護．お金がきちんと計上されることを常に確認．
    - ブラックボックス or ホワイトボックス
    - 使う人: 目が見えない人でも使えるように．
    - 目的: 引き出し，振込，残高照会など．
    - テスト可能な要素への切り分け
        - ログイン
        - 預金の引き出し
        - 預入
        - 残高照会
        - 振込
    - 手動テスト
        - 各ステップについて，エラーになりそうなケースを確かめる．
            - 残高不足，新規口座，存在しない口座
    - 自動テスト
        - 手動より複雑．標準的なシナリオを自動化．
        - 競合状態のような特殊な問題も調べる．
        - 架空の口座を用意した閉じたシステムを用意する．
        - 入出金を異なる場所から素早く行っても，預金者のお金が増えたり減ったりしないことを確認する．

(Ch12, 13はなし)

## Ch14 DB

- 14.1 AptTenantsから2つ以上あるIDをとって結合すればOK．
- 14.2 結合すればOK．
- 14.3 where句で#11の建物のアパートIDを取ってくるサブクエリを使う．
- 14.4 具体的な2テーブルでどうなるか示せばよいらしい．
    - INNER
    - OUTER
        - LEFT, RIGHT, FULL
        - 結合元は除外されない．
        - FULLは，結合できる行が同一行になって，ほかはそれぞれの行で出てくる．
- 14.5
    - 非正規化の長短
        - 長所
            - 結合が少なく読み込み速い
            - 操作テーブルがクエリが単純
        - 短所
            - データの更新・追加のコストが大きい．クエリも難しくなる．
            - 整合性が取りづらい．
            - 保存領域増．
- 14.6
    - ISAとかN対1とか書く．あとは属性，関係と属性を書けばよいらしい．
- 14.7
    - 生徒でグループ化して点数平均を取る．
    - 足きり点を先にとっておき，それを条件にすれば取得できる．
    - 仮定をしたことを認識することが重要．
    - 柔軟性と複雑性のトレードオフ．

## Ch15 スレッドとロック

- 何か1冊読んでから取り組みたい．
- 15.1
    - プロセス
        - 実行時のプログラムのインスタンス．システムリソースを割り当てられるように独立した実体．
        - 各プロセスは異なるアドレス空間．
        - パイプ，ファイル，ソケットなどでプロセス間通信．
    - スレッド
        - プロセスの中にあり，プロセスのリソースを共有する．
        - ヒープ領域を共有．1つのスレッドでリソースを変更すれば，ほかのスレッドでも即座に見られる．
- 15.2
    - コンテキストスイッチ: 2つのプロセスの切り替え．
    - コンテキストスイッチの時間の計測
        - プロセス間でトークンを送受信して，コンテキストスイッチの発生を検知する．
        - 全体の経過時間を，トークンの送受信にかかる時間とコンテキストスイッチにかかる時間の和で表せる．
        - トークンの送受信にかかる時間を計測することで，コンテキストスイッチにかかる時間を計算できる．
- 15.3
    - 食事する哲学者
    - 全か無か → 完全に同時に動くと，ライブロックになる．
    - または，箸に優先度をつけて循環を回避する．
- 15.4
    - デッドロック・フリー
    - グラフを使う．
    - 使用順序を宣言させて，グラフにする．
        - サイクルがなければOK．
        - 宣言どおりの順番でロックしていることを確認しながらロックを取る．
- 15.5
    - second()の前にfirst()の完了チェック，third()の前にsecond()の完了チェック
    - これをロックやセマフォで実装する
    - Javaのロックは，ロックしたスレッドのみから所有されるものとしているため，ここではセマフォ．
- 15.6
    - オブジェクトのインスタンスに対して実行できる同期メソッドはたった1つ．
    - → 同期メソッドは，そのオブジェクトのインスタンスのすべての同期メソッドに対してロックを行う．
- 15.7
    - スレッドのインスタンスを4つ持つ．
    - 走らせておけばよいらしい．


## Ch16 中級編

- 16.1 数値の入れ替え
    - diffをとればいける．数直線で考える．
    - XORでもできる．
- 16.2
    - 単語の出現頻度
    - 1語ならO(n)
    - 複数語ならハッシュテーブルを作る．
- 16.3
    - Line, Pointをつくって読みやすいコードを書く問題．
- 16.4 〇×ゲーム
    - 簡潔で保守しやすいコーディング方法への理解を問うている．
- 16.5 階乗
    - 単純にその数までに5が何個あるか数えればよい．
    - nを5で割れる数が答えになる．
- 16.6 最小の差
    - 2つの組み合わせの比較
    - → 2組ともソートして，2つのポインタを使ってそれぞれの組を走査していく．比較の大小によって動かすポインタを選ぶ．
- 16.7
    - 最大値を比較しないで求める場合は，符号を用いる．負なら0として最大でない方にかけることで，最大値を返す．
    - オーバーフロー対策として，符号が異なる場合は引き算でない方法で求める．
- 16.8
    - 3桁ずつ区切って，thousandやmillionを入れていく．
- 16.9
    - 加算だけで減乗除算する．
    - 減算
        - 符号反転
        - -1, -2, -4, -8, ..というように数字を引いていく
        - O((loga)^2)
    - 正だったりという誤った過程を置かないことが重要．
- 16.10
    - 増える年のリストと減る年のリストをソートする．
    - 2つのリストのインデックスを操作する．
    - または，年の範囲でリストを作り，変化量（増えた年，減った年）だけを記録する．
    - → 変化量を計算していって最大値のインデックスを返せばよい．
- 16.11
    - 単純にK枚の板の組み合わせを調べればいい．
- 16.12
    - 木構造のような形で実装する．
    - encode()メソッドを使う．
- 16.13
    - 正方形を2分割: 中心を通る直線．
    - 特殊なケースへの対応が必要な問題．
- 16.14 点のある2次元グラフ
    - それぞれの2点間で直線を作る．傾きをキーとしたハッシュテーブルを作る．
    - ハッシュテーブルには平行な直線のリストを持ち，切片が同じなら同じ直線としてカウントする．
    - 傾きの等しさは，ε（許容誤差）で丸めて判定する．keyはεで丸まった値となる．
    - 垂直な直線は別で処理．
- 16.15
    - マスターマインドっていうらしい．なんかヌメロンとかいうやつがあったけどそれと同じ．
    - ヒットを数えているときに，あわせて頻度配列を計算しておけば，ブローも数えられる．
- 16.16
    - ソート済みの部分配列を見つける．
    - 左と右でそれぞれソート済みの部分配列見つける．中央も部分配列になる．
    - → 左側，右側それぞれの部分配列について，それより左または右のminまたはmaxと比較することで，どこまでがソート済みかわかる．
- 16.17
    - 連続する数列の和の最大値．
    - 正の数と負の数をまとめた場合を考えると分かりやすい．
    - それまでの和と次の負の数の和がプラスになる場合は，それまでのmax_sumとは別にsumを計算して持っておき，次の正の数との和と比較する．
- 16.18
    - パターンマッチ
    - パターンも値も与えられている．
    - → 値の中から，片方のパターンを選んでいくだけでできる．
    - 部分文字列で比較していく場合は，早めにfalseを返せる．
- 16.19
    - 0の範囲
    - **頂点間の関係の問題はグラフの問題として解く**．dfsとかで出せる．
    - 見たところは0でない値にしておけばよい．
    - dfs: 再帰を使って簡単に実装できる．
- 16.20
    - 組み合わせ間の比較．
    - 文字列を，T9表現にしてハッシュテーブルに入れればよい．
- 16.21
    - 2組のそれぞれの合計を同じ値にする．
    - とりあえずそれぞれの合計を出して，目的のペアの関係を求める．
    - 片方の配列をハッシュテーブルに入れると，もう片方の配列のそれぞれの値に対して目的の値があるかどうかO(1)で分かるようになる．
    - または，ソートしてそれぞれのポインタを操作すると，少ない空間で解ける．
- 16.22
    - ラングトンのアリ
    - 片方の色のポジションをハッシュセットで保持する．
    - 左上の行・列と右下の行・列の値を用意する．
    - Positionを用意する．
    - あとはハッシュセットを操作すればOK．
- 16.23
    - rand5 to rand7
    - rand5を組み合わせて，すべてが均等に出てくる数字の組を作る．
    - → rand5 * 5は，rand5の値とかぶらないため，rand5 * 5 + rand5をすることで，0から20までの値をランダムな確率で出せる．
    - → 出た値の%7が答えになる．
- 16.24
    - ハッシュテーブルを使えばOK．
    - ソートしてfirst, lastの操作もあり．
- 16.25
    - LRUキャッシュ
    - ハッシュテーブルと連結リストを使う．
- 16.26
    - 計算機
    - ナンバースタックとオペレータスタックを作る．オペレータスタックの最上位と次の演算子を比較して，スタックの演算子が優先されるときは，演算して畳んでしまう．
    - または，processing, resultをそれぞれ持っておくことでもできる．
    - 次の演算子を見る処理が重要．

## Ch17 上級編

- 17.1 +を使わない足し算
    - ビット演算で計算する．
    - 繰り上げなしの加算と，繰り上げのみの加算を組み合わせる．繰り上げがなくなるまで再帰的に実施する．
- 17.2
    - シャッフル
    - n-1枚でシャッフル済みのデッキに対して，n番目の要素と配列内の要素をランダムに入れ替えればOK．
- 17.3
    - ランダムな集合
    - これも初期状態からの積み上げでいける．
    - 乱数をとって，m以下ならarr[i]を乱数の位置にセットする．
- 17.4
    - 迷子の数．ビットで確かめる．
    - 最下位のビットの0の数と1の数を数える．
    - 数の大小で，vがどちらに含まれるか分かる．含まれない方を除外する．
    - n, n/2, n/4, ..と検査対象が減っていくので，O(N)で済む．
- 17.5
    - 2種類の文字が同じ数の部分配列を求める．
    - それぞれの文字の数の差をとる．同じ差となるインデックスの間は，条件を満たす部分配列になる．
    - ハッシュテーブルにそれぞれの差の最初の位置を持っておき，それとの差をとっていって，cur_maxを更新していけばOK．
- 17.6
    - 2を数える．
    - 各桁で数えていく．各桁の値が2より大きい・等しい・小さいによって，その桁以下を切り捨てるか切り上げるか決める．
    - 等しい場合は，その桁より右の数字+1個ある．
- 17.7
    - baby's name
    - 同一視→グループ化→UnionFindでよいのかも．
    - それぞれのグループについて計算する．
- 17.8
    - 2つの要素の配列の部分配列の最大の長さ．
    - 片方でソートして，各要素で終わる最長の部分列を保持していく．
    - 最大の長さとなったものが答え．
- 17.9
    - K番目の倍数．ハミングの問題．
    - 次の数字は，これまでの数字に3,5,7のいずれかをかけたものになる．
    - → 3,5,7それぞれで次の要素のキューを持つ．
    - 3は3,5,7をかけたもの，5は5,7をかけたもの，7は7をかけたものだけ持っておけばよい．
    - 3,5,7のキューの頭を比較して最小をとっていけばよい．
- 17.10
    - 過半数の要素
    - 列の最初の要素を数えて，過半数でなくなった時点でその要素のチェックはやめる．
    - 対象の要素と同数以下の要素もチェック不要なので，チェックしたところの次からまたチェックしていけばよい．
    - 部分配列に過半数の要素がなければ，それ以外の部分配列だけ確認してもよい．
- 17.11
    - 単語の距離
    - 各単語をキーとしたハッシュテーブルに，順番を格納しておけばよい．
    - 1回限りなら，ハッシュテーブルも不要．
- 17.12
    - BiNode
    - 再帰的に作っていく．
    - headを返して，tailも参照できるようにすればよい．
- 17.13
    - 分かち書き
    - 発電計画問題・区間最小二乗法・各種スケジューリング問題にも使える．
    - 1列に並んだN個の対象物を区間に分割する方法の最適化．
    - dp[i]: 区間[0,i)について，いくつかの区間に分割する最小のコスト．
    - 無効な文字の数がコストになる．
- 17.14
    - 小さい方からK番目までの数を求める．
    - 選択順位アルゴリズムというのを使う．
    - ピボットを選択して，左側にはピボットより小さい値，右側は逆にする．
    - 左側・右側の要素の個数に注目して，どちらかに再帰的に実行する．
- 17.15
    - 最長の単語の組
    - 降順にソートして，n語に分割できるか再帰的に調べる．
    - 2語で簡単ならn語でも再帰にすればできるっていう発想．
- 17.16
    - マッサージのスケジュール
    - 要素間の関係があるときは，グラフなどを作ってみるとよい．
    - 選ぶ/選ばないで再帰で解ける → dp
    - 実際は，3個続けて選ばないことはないことから，後ろ2つの最良値を持っておいて，後ろから見ていけばよい．
- 17.17
    - 複数の文字列それぞれが，ある文字列に含まれるか．
    - トライ木を作る．
    - 頭文字から探索したいときは，トライ木を作ってみるといい．
- 17.18
    - 最短の部分配列
    - 配列のインデックスを値，それぞれの値をキーとしてハッシュテーブルを作り，3つの要素の範囲を最小を削除→新しく追加していって長さを見ていく．
    - それぞれの長さについては，ヒープを作って最小値を簡単に取れるようにする．
    - ↑ 挿入・max, minの取得・削除はヒープが〇．
    - または，次に要素が出てくるインデックスを持つテーブルを作っておけばよい．
- 17.19
    - 迷子の数（10進表記）
    - 計算について
        - 固有・逆算できる・定数時間・定数空間が条件
    - 和を取って1～nの和との差を取ればいい．
    - 2つの数がないときは，和と積をともに求めて，方程式を解けばよい．
    - 積よりは，それぞれの二乗の和を取った方が小さな値で済む．
- 17.20
    - 連続的な中央値
    - 中央値より小さい値をmaxヒープ，大きい値をminヒープで持っておけばいける．
    - 半分に分けて最大と最小がわかれば，中間も取れる．
- 17.21
    - maxを見つけて，左右をそれぞれの部分グラフとしてみる．
    - 与えられた場所から端までの最大値を保持する配列を左右それぞれで持っておけば，最大値の検索が要らなくなる．
    - または，上のデータを持っておけば，再帰せずに，両端のmaxの小さい方と高さとの差を取れば，それが水量になる．
- 17.22
    - 単語変換
    - ワイルドカード形式でハッシュマップを作成し，1変換分離れた単語のリストを取れるようにする．
    - 始点と終点からそれぞれBFS．
- 17.23
    - 最大の黒い正方形
    - シンプルに解くと，N * N, (N-1)*(N-1),..というように調べていく．
    - 右側と下側にどれだけ黒がつながっているかDPで計算しておくことで，O(N^3)になる．
- 17.24
    - DPをあわせていく．
    - row_start, row_endでループして，行に対して，部分配列の和の最大値を求めるようにして最大値をとっていく．
- 17.25
    - 短形の単語はすべて同じ長さ → 同じものをグループ化．
    - 長さごとに調べていく．それぞれで必要になったらトライ木を作る．
    - 横縦の長さでそれぞれ単語リストがなければ飛ばす．あったときは，メモにトライ木がないときだけトライ木を作る．
    - 単語のリストから短形を作っていく．すべて単語の接頭辞になっていれば，それに追加していく．
    - 行はリストから追加し，列について1文字ずつ追加していく．
- 17.26
    - 同じ要素を持つドキュメントのペアを出す．類似度も出す．
    - → 共通があるペアを返す，計算もする．
    - 各ドキュメントのすべての要素について，ハッシュテーブルを作る．
    - 各要素について複数のドキュメントがあるとき，それらが結果のペアになる．
    - ペアの共通集合のサイズも，ハッシュマップのキーをドキュメントのペアとして，サイズをマップしていく．→ 共通集合のサイズが取りやすくなる．
    - または，すべての単語をドキュメントIDでタグ付けして，全体でソートすればよい．