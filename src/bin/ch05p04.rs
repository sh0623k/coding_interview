/*
 3つのステップに分ける．
 最下位ビットから連続する0以外の最も右の0を反転→反転したビットの右の1の個数を数えてクリア→右から1の個数分1を埋める．
 下のように，算術的にも解くことができる．
 反転→クリアするときは，最下位ビットから連続する0をすべて1にするため，2^(0の個数)-1を足して，1を足すことで実行できる．
 右から1の個数分1を埋めるときも，2^(1の個数-1)-1を足せば求められる．
 → next = n + 2^(0の個数) - 1 + 1 + 2^(1の個数-1) - 1となる．
 前の値も同様に求められる．
*/

fn main() {}